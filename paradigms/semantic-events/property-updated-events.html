<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title> | Compze </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content=" | Compze ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/mlidbom/Compze/blob/new_website_structure/Website/paradigms/semantic-events/property-updated-events.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="Compze">
            Compze
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">

<h4 id="adding-properties-to-our-events">Adding properties to our events</h4>
<p>You may have noticed that the events on the last page were missing a little something, namely properties.<br>
Now the natural expectation would be for a slightly more realistic version of something like this:</p>
<pre><code class="lang-csharp">interface IUserRegistered : IUserEvent, IAggregateCreatedEvent;
interface IUserChangedEmail : IUserEvent;
</code></pre>
<p>to be something like this:</p>
<pre><code class="lang-csharp">interface IUserRegistered : IUserEvent, IAggregateCreatedEvent
{
   Email Email { get; }
}

interface IUserChangedEmail : IUserEvent
{
   Email Email { get; }
}
</code></pre>
<p>However, doing that does not work well at all.</p>
<h4 id="the-dilemma-of-fine-grained-vs-coarse-grained-events">The dilemma of Fine-grained vs Coarse-grained events</h4>
<p>The reason the above code is terrible idea, is that some event listeners care only about updated data, and others care about semantics. If we do things like above, the code that care only about data will not only have to know about and manually listen to every single concrete event in the system that updates <code>Email</code>, we must keep track of every such listener for every single aggregate property in our whole system, and update  each of them every time a new event that updates a user email is created üò®</p>
<p>Classically the above problem has lead to projects being forced to choose between using fine-grained property-updated events and coarse-grained semantically meaningful domain events. The problem is that both choices are maintainability disasters. If you go with property-updated style events you lose virtually all ability to understand the semantics of what happened, as a single user interaction is exploded into a number of individual data atoms üò¨ If you go with coarse-grained events, we run head first into the issues described in the previous paragraph. You cannot win as long as you accept the choice.</p>
<h4 id="unifying-fine-grained-and-coarse-grained-events">Unifying Fine-grained and Coarse-grained events</h4>
<p>With semantic events you don't need to choose. If you do this:</p>
<pre><code class="lang-csharp">interface IUserEmailPropertyUpdated : IUserEvent
{
   Email Email { get; }
}

interface IUserRegistered : IUserEmailPropertyUpdated, IAggregateCreatedEvent;
interface IUserChangedEmail : IUserEmailPropertyUpdated;
</code></pre>
<p>The whole problem disappears like it never existed ‚ò∫Ô∏è<br>
When we design events like that, a listener like this ...</p>
<pre><code class="lang-csharp">eventHandlerRegistrar
  .ForEvent&lt;IUserEmailPropertyUpdated&gt;(emailUpdated =&gt; WriteLine($&quot;User: {emailUpdated.AggregateId} Email: {emailUpdated.Email}&quot;));
</code></pre>
<p>... will never need to change throughout the whole lifetime of the system. It will be called whenever a user's email is updated. Period.</p>
<p>Likewise, listeners that care about when users are registered will listen to <code>IUserRegistered</code> and receive the same benefits. No matter how many new ways of registering users we add, no matter how many new subtypes of <code>IUserRegistered</code> are added. That code will always be called and does not need to change.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/mlidbom/Compze/blob/new_website_structure/Website/paradigms/semantic-events/property-updated-events.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
